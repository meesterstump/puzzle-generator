import { PuzzleTopology, Vec2 } from "../geometry/types";

/**
 * Generates an SVG string representation of the puzzle's cut lines.
 *
 * @param topology - The puzzle topology containing the geometric data.
 * @param width - The width of the SVG viewport.
 * @param height - The height of the SVG viewport.
 * @param pieceColor - Optional color to draw the pieces (default black)
 * @returns A string containing the complete SVG markup.
 */
export function createSVG(topology: PuzzleTopology, width: number, height: number, pieceColor = "black"): string {
  // how many digits to preserve when converting decimal numbers to SVG string
  const precisionDigits = 3;

  // Array to hold the individual path commands (e.g., "M 10 10", "L 100 100").
  const pathData: string[] = [];

  // Iterate over each unique edge, ensuring each cut is only defined once.
  for (const edge of topology.edges.values()) {
    const he = topology.halfEdges.get(edge.heLeft);
    if (!he) continue;

    // SVG Path Command: "M" - move to the starting point of the half-edge.
    pathData.push(`M ${he.origin[0].toFixed(precisionDigits)} ${he.origin[1].toFixed(precisionDigits)}`);

    if (he.segments) {
      // if a custom tab is defined, draw each segment in order
      for (const segment of he.segments) {
        switch (segment.type) {
        case 'bezier':
          // SVG Path Command: "C" - draw a cubic BÃ©zier curve.
          pathData.push(
            `C ${segment.p1[0].toFixed(precisionDigits)} ${segment.p1[1].toFixed(precisionDigits)}, ` +
            `${segment.p2[0].toFixed(precisionDigits)} ${segment.p2[1].toFixed(precisionDigits)}, ` +
            `${segment.p3[0].toFixed(precisionDigits)} ${segment.p3[1].toFixed(precisionDigits)}`
          );
          break;
        case 'line':
          // SVG Path Command: "L" - draw a straight line to the destination.
          pathData.push(`L ${segment.p[0].toFixed(precisionDigits)} ${segment.p[1].toFixed(precisionDigits)}`);
          break;
        }
      }
    } else {
      // SVG Path Command: "L" - draw a straight line to the destination.
      let destination: Vec2;
      if (he.twin !== -1) {
        // Internal edge: destination is the start of the twin half-edge.
        const twinHe = topology.halfEdges.get(he.twin)!;
        destination = twinHe.origin;
      } else {
        // Boundary edge: destination is the start of the next half-edge.
        const nextHe = topology.halfEdges.get(he.next)!;
        destination = nextHe.origin;
      }
      pathData.push(`L ${destination[0].toFixed(precisionDigits)} ${destination[1].toFixed(precisionDigits)}`);
    }
  }

  // Join all path commands into a single string for the 'd' attribute.
  const pathD = pathData.join(' ');

  // Construct the final SVG markup.
  // The <path> element uses vector-effect="non-scaling-stroke" which is a best
  // practice for laser cutting files, as it ensures the line width remains
  // constant regardless of scaling.
  const svgString = `
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg
  width="${width}"
  height="${height}"
  viewBox="0 0 ${width} ${height}"
  xmlns="http://www.w3.org/2000/svg"
  version="1.1"
>
  <path
    d="${pathD}"
    fill="none"
    stroke="${pieceColor}"
    stroke-width="1"
    vector-effect="non-scaling-stroke"
  />
</svg>`
    .trim() // strip leading and trailing whitespace
    .replace(/\r\n/g, '\n'); // use unix line endings for max compatibility

  return svgString;
}


/**
 * Offers a SVG file for download
 * @param svg SVG string as generated by drawSVG()
 * @param filename Optional name of file for download
 */
export function downloadSvg(svg: string, filename = "puzzle.svg") {
  // create a blob from the SVG string
  const blob = new Blob([svg], { type: "image/svg+xml" });

  // create a temporary object URL for the blob
  const url = URL.createObjectURL(blob);

  // create a hidden <a> element with the download attribute
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.hidden = true;

  // click it
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);

  // clean up
  setTimeout(() => URL.revokeObjectURL(url), 100);
}
